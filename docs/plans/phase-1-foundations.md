# Phase 1: Foundations - Detailed Implementation Spec

**Parent document**: [SpeedFog Design](./2026-01-29-speedfog-design.md)
**Related**: [Cluster Generation Spec](./generate-clusters-spec.md)
**Status**: Implemented

## Objective

Set up the project structure and create the data pipeline:
1. Generate `clusters.json` from FogRando's `fog.txt`
2. Create the Python package structure
3. Implement config and cluster parsers

## Prerequisites

- Python 3.10+
- Access to FogRando's `fog.txt` at: `reference/fogrando-data/fog.txt`

## Deliverables

```
speedfog/
├── core/
│   ├── speedfog_core/
│   │   ├── __init__.py
│   │   ├── config.py          # Task 1.2: Configuration parsing
│   │   ├── clusters.py        # Task 1.3: Cluster data structures
│   │   └── main.py            # CLI entry point
│   ├── data/
│   │   ├── clusters.json      # Generated by generate_clusters.py
│   │   └── zone_metadata.toml # Optional: weight overrides
│   └── config.toml            # Example configuration
├── tools/
│   └── generate_clusters.py   # Task 1.1: Generate clusters.json
├── pyproject.toml
└── README.md
```

---

## Task 1.1: generate_clusters.py

Generate `clusters.json` from FogRando's `fog.txt`. This is a **one-time preprocessing step** that computes all possible zone clusters with their entry/exit fogs.

See [generate-clusters-spec.md](./generate-clusters-spec.md) for the complete specification.

### Summary

A **cluster** is a group of zones connected by world connections. The script:
1. Parses `fog.txt` (Areas, Entrances, Warps sections)
2. Builds a graph of world connections between zones
3. Generates all valid clusters (reachable zone groups)
4. Computes `entry_fogs` and `exit_fogs` for each cluster
5. Outputs `clusters.json`

### Usage

```bash
python tools/generate_clusters.py \
    reference/fogrando-data/fog.txt \
    core/data/clusters.json \
    --exclude-dlc \
    --exclude-overworld
```

### Output Format

```json
{
  "version": "1.0",
  "generated_from": "fog.txt",
  "cluster_count": 275,
  "clusters": [
    {
      "id": "stormveil_start_c1d3",
      "zones": ["stormveil_start", "stormveil"],
      "type": "legacy_dungeon",
      "weight": 20,
      "entry_fogs": [
        {"fog_id": "margit_front", "zone": "stormveil_start"}
      ],
      "exit_fogs": [
        {"fog_id": "margit_front", "zone": "stormveil_start"},
        {"fog_id": "godrick_front", "zone": "stormveil"}
      ]
    }
  ]
}
```

---

## Task 1.2: config.py

Parse user configuration from TOML.

### config.py

```python
"""Configuration parsing for SpeedFog."""

from __future__ import annotations

import sys
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any

if sys.version_info >= (3, 11):
    import tomllib
else:
    try:
        import tomli as tomllib
    except ImportError as e:
        raise ImportError(
            "tomli is required for Python < 3.11. Install with: pip install tomli"
        ) from e


@dataclass
class BudgetConfig:
    """Path budget configuration."""
    total_weight: int = 30
    tolerance: int = 5

    @property
    def min_weight(self) -> int:
        return self.total_weight - self.tolerance

    @property
    def max_weight(self) -> int:
        return self.total_weight + self.tolerance


@dataclass
class RequirementsConfig:
    """Minimum requirements for generated runs."""
    legacy_dungeons: int = 1
    bosses: int = 5
    mini_dungeons: int = 5


@dataclass
class StructureConfig:
    """DAG structure parameters."""
    max_parallel_paths: int = 3
    min_layers: int = 6
    max_layers: int = 10


@dataclass
class PathsConfig:
    """File paths configuration."""
    game_dir: str = ""
    output_dir: str = "./output"
    clusters_file: str = "./data/clusters.json"
    randomizer_dir: str | None = None


@dataclass
class Config:
    """Main SpeedFog configuration."""
    seed: int = 0
    budget: BudgetConfig = field(default_factory=BudgetConfig)
    requirements: RequirementsConfig = field(default_factory=RequirementsConfig)
    structure: StructureConfig = field(default_factory=StructureConfig)
    paths: PathsConfig = field(default_factory=PathsConfig)

    @classmethod
    def from_toml(cls, path: Path) -> Config:
        """Load configuration from TOML file."""
        with open(path, 'rb') as f:
            data = tomllib.load(f)
        return cls.from_dict(data)

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> Config:
        """Create Config from dictionary."""
        run = data.get('run', {})
        budget = data.get('budget', {})
        requirements = data.get('requirements', {})
        structure = data.get('structure', {})
        paths = data.get('paths', {})

        return cls(
            seed=run.get('seed', 0),
            budget=BudgetConfig(
                total_weight=budget.get('total_weight', 30),
                tolerance=budget.get('tolerance', 5),
            ),
            requirements=RequirementsConfig(
                legacy_dungeons=requirements.get('legacy_dungeons', 1),
                bosses=requirements.get('bosses', 5),
                mini_dungeons=requirements.get('mini_dungeons', 5),
            ),
            structure=StructureConfig(
                max_parallel_paths=structure.get('max_parallel_paths', 3),
                min_layers=structure.get('min_layers', 6),
                max_layers=structure.get('max_layers', 10),
            ),
            paths=PathsConfig(
                game_dir=paths.get('game_dir', ''),
                output_dir=paths.get('output_dir', './output'),
                clusters_file=paths.get('clusters_file', './data/clusters.json'),
                randomizer_dir=paths.get('randomizer_dir'),
            ),
        )


def load_config(path: Path) -> Config:
    """Load configuration from file, with defaults for missing values."""
    if not path.exists():
        raise FileNotFoundError(f"Config file not found: {path}")
    return Config.from_toml(path)
```

### Example config.toml

```toml
[run]
seed = 0  # 0 = auto-reroll until valid DAG found

[budget]
total_weight = 30
tolerance = 5

[requirements]
legacy_dungeons = 1
bosses = 5
mini_dungeons = 5

[structure]
max_parallel_paths = 3
min_layers = 6
max_layers = 10

[paths]
game_dir = "C:/Program Files/Steam/steamapps/common/ELDEN RING/Game"
output_dir = "./output"
clusters_file = "./data/clusters.json"
# randomizer_dir = "./mods/randomizer"  # Optional
```

---

## Task 1.3: clusters.py

Load and manage clusters from `clusters.json`.

### clusters.py

```python
"""Load and manage clusters from clusters.json."""

from __future__ import annotations

import json
from dataclasses import dataclass, field
from pathlib import Path


@dataclass
class ClusterData:
    """A cluster loaded from clusters.json."""

    id: str
    zones: list[str]
    type: str  # start, final_boss, legacy_dungeon, mini_dungeon, boss_arena
    weight: int
    entry_fogs: list[dict]  # [{"fog_id": str, "zone": str}, ...]
    exit_fogs: list[dict]   # [{"fog_id": str, "zone": str, "unique"?: bool}, ...]

    @classmethod
    def from_dict(cls, data: dict) -> ClusterData:
        """Create ClusterData from a dictionary."""
        return cls(
            id=data["id"],
            zones=data["zones"],
            type=data["type"],
            weight=data["weight"],
            entry_fogs=data.get("entry_fogs", []),
            exit_fogs=data.get("exit_fogs", []),
        )

    def available_exits(self, used_entry_fog: str | None) -> list[dict]:
        """Get exit fogs available after using an entry fog.

        If the entry fog is bidirectional (appears in both entry and exit),
        it's removed from available exits.
        """
        if used_entry_fog is None:
            return list(self.exit_fogs)

        return [f for f in self.exit_fogs if f["fog_id"] != used_entry_fog]


@dataclass
class ClusterPool:
    """Collection of clusters grouped by type."""

    clusters: list[ClusterData] = field(default_factory=list)
    by_type: dict[str, list[ClusterData]] = field(default_factory=dict)
    by_id: dict[str, ClusterData] = field(default_factory=dict)

    def add(self, cluster: ClusterData) -> None:
        """Add a cluster to the pool."""
        self.clusters.append(cluster)
        self.by_id[cluster.id] = cluster
        if cluster.type not in self.by_type:
            self.by_type[cluster.type] = []
        self.by_type[cluster.type].append(cluster)

    def get_by_type(self, cluster_type: str) -> list[ClusterData]:
        """Get all clusters of a given type."""
        return self.by_type.get(cluster_type, [])

    def get_by_id(self, cluster_id: str) -> ClusterData | None:
        """Get a cluster by ID."""
        return self.by_id.get(cluster_id)

    @classmethod
    def from_json(cls, path: Path) -> ClusterPool:
        """Load cluster pool from JSON file."""
        with open(path, encoding="utf-8") as f:
            data = json.load(f)

        pool = cls()
        for cluster_data in data.get("clusters", []):
            cluster = ClusterData.from_dict(cluster_data)
            pool.add(cluster)

        return pool


def load_clusters(path: Path) -> ClusterPool:
    """Load clusters from JSON file.

    Args:
        path: Path to clusters.json

    Returns:
        ClusterPool with all clusters loaded

    Raises:
        FileNotFoundError: If the file doesn't exist
    """
    if not path.exists():
        raise FileNotFoundError(f"Clusters file not found: {path}")
    return ClusterPool.from_json(path)
```

---

## Task 1.4: Project Structure

### pyproject.toml

```toml
[project]
name = "speedfog-core"
version = "0.1.0"
description = "SpeedFog DAG generator for Elden Ring zone randomization"
requires-python = ">=3.10"
dependencies = [
    "tomli>=2.0.0;python_version<'3.11'",
    "pyyaml>=6.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0",
    "pytest-cov>=4.0",
    "ruff>=0.1.0",
]

[project.scripts]
speedfog = "speedfog_core.main:main"

[build-system]
requires = ["setuptools>=61.0"]
build-backend = "setuptools.build_meta"

[tool.ruff]
line-length = 100
target-version = "py310"
```

### README.md

```markdown
# SpeedFog Core

DAG generator for SpeedFog - an Elden Ring mod that creates short randomized runs.

## Installation

```bash
cd core
pip install -e .
```

## Usage

```bash
# Generate DAG with auto-reroll
speedfog config.toml -o graph.json --spoiler spoiler.txt -v

# Generate with fixed seed
speedfog config.toml --seed 12345 -o graph.json
```

## Configuration

See `config.toml` for all options. Key settings:

- `seed`: Random seed (0 = auto-reroll until valid)
- `budget.total_weight`: Target run duration in minutes
- `requirements.*`: Minimum zone counts
- `structure.max_parallel_paths`: Maximum parallel branches

## Data Pipeline

1. `generate_clusters.py` (one-time): fog.txt → clusters.json
2. `speedfog` (per run): config.toml + clusters.json → graph.json
3. C# writer (per run): graph.json → mod files
```

---

## Acceptance Criteria

### Task 1.1 (generate_clusters.py)
- [x] Script parses fog.txt correctly
- [x] Generates valid clusters with entry/exit fogs
- [x] Excludes DLC and overworld zones
- [x] Output matches expected JSON schema
- [x] Cluster count ~200-300 for base game

### Task 1.2 (config.py)
- [x] `Config.from_toml()` parses config correctly
- [x] Default values work when sections are missing
- [x] `BudgetConfig.min_weight` and `.max_weight` compute correctly
- [x] `paths.clusters_file` field exists

### Task 1.3 (clusters.py)
- [x] `ClusterPool.from_json()` loads clusters correctly
- [x] `get_by_type()` returns correct clusters
- [x] `available_exits()` correctly removes used entry fog

### Task 1.4 (Project Structure)
- [x] `pyproject.toml` exists and `pip install -e .` succeeds
- [x] `speedfog` CLI command works
- [x] README with basic usage

---

## Testing

### Unit Tests (tests/test_config.py)

```python
import pytest
from speedfog_core.config import Config, BudgetConfig

def test_budget_min_max():
    budget = BudgetConfig(total_weight=30, tolerance=5)
    assert budget.min_weight == 25
    assert budget.max_weight == 35

def test_config_defaults():
    config = Config.from_dict({})
    assert config.seed == 0
    assert config.budget.total_weight == 30
    assert config.requirements.bosses == 5
    assert config.paths.clusters_file == "./data/clusters.json"

def test_config_from_toml(tmp_path):
    config_file = tmp_path / "config.toml"
    config_file.write_text("""
[run]
seed = 42

[budget]
total_weight = 25
""")
    config = Config.from_toml(config_file)
    assert config.seed == 42
    assert config.budget.total_weight == 25
```

### Unit Tests (tests/test_clusters.py)

```python
import pytest
import json
from speedfog_core.clusters import ClusterData, ClusterPool

def test_cluster_available_exits():
    cluster = ClusterData(
        id="test",
        zones=["zone_a", "zone_b"],
        type="legacy_dungeon",
        weight=10,
        entry_fogs=[{"fog_id": "fog_1", "zone": "zone_a"}],
        exit_fogs=[
            {"fog_id": "fog_1", "zone": "zone_a"},
            {"fog_id": "fog_2", "zone": "zone_b"},
        ],
    )

    # Without using entry fog
    exits = cluster.available_exits(None)
    assert len(exits) == 2

    # After using fog_1 as entry (bidirectional)
    exits = cluster.available_exits("fog_1")
    assert len(exits) == 1
    assert exits[0]["fog_id"] == "fog_2"

def test_cluster_pool_by_type(tmp_path):
    clusters_file = tmp_path / "clusters.json"
    clusters_file.write_text(json.dumps({
        "clusters": [
            {"id": "c1", "zones": ["z1"], "type": "legacy_dungeon", "weight": 10,
             "entry_fogs": [], "exit_fogs": []},
            {"id": "c2", "zones": ["z2"], "type": "mini_dungeon", "weight": 5,
             "entry_fogs": [], "exit_fogs": []},
            {"id": "c3", "zones": ["z3"], "type": "legacy_dungeon", "weight": 15,
             "entry_fogs": [], "exit_fogs": []},
        ]
    }))

    pool = ClusterPool.from_json(clusters_file)

    legacy = pool.get_by_type("legacy_dungeon")
    assert len(legacy) == 2

    mini = pool.get_by_type("mini_dungeon")
    assert len(mini) == 1
```

---

## Next Phase

After completing Phase 1, proceed to [Phase 2: DAG Generation](./phase-2-dag-generation.md).
